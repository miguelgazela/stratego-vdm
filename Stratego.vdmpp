/**
  Stratego.

  <p>
  description
  </p>

  @version
  @author
*/

class Stratego

types
    public String = seq of char;
    public PieceConf :: name: String
                        rank: nat
                        quantity: real;   

values
    private SCOUT: nat = 2;

instance variables
    private defaultPieces: seq of PieceConf := [];
    --inv len defaultPieces = 12;

    private playerOne: Player;
    private playerTwo: Player;
    private board: Board;
    private currentPlayer: Player;
    --inv currentPlayer = playerOne or currentPlayer = playerTwo;

    -- inv este plauer tem que ser o plauerone ou o player2
operations


-- constructor for Stratego
public Stratego() res: Stratego == (
    board := new Board();
    playerOne := new Player("P1", <Blue>);
    playerTwo := new Player("P2", <Red>);
    currentPlayer := playerOne;
    initGame();
    return self;
);

-- consult operations
    

private initPieceConfigurations: () ==> ()
initPieceConfigurations() == (
    defaultPieces := [
        mk_PieceConf("FLAG",0,1), mk_PieceConf("SPY",1,1),
        mk_PieceConf("SCOUT",2,8), mk_PieceConf("MINER",3,5),
        mk_PieceConf("SERGEANT",4,4), mk_PieceConf("LIUTENANT",5,4),
        mk_PieceConf("CAPTAIN",6,4), mk_PieceConf("MAJOR",7,3),
        mk_PieceConf("COLONEL",8,2), mk_PieceConf("GENERAL",9,1),
        mk_PieceConf("MARSHAL",10,1), mk_PieceConf("BOMB",11,6)
    ];
)
pre defaultPieces = []
post len defaultPieces = 12
    and not exists pieceConf1, pieceConf2 in set elems defaultPieces & 
        pieceConf1 <> pieceConf2
        and pieceConf1.name = pieceConf2.name
        and pieceConf1.rank = pieceConf2.rank
        and not {pieceConf1.name, pieceConf2.name} subset {"FLAG", "SPY", "SCOUT", "MINER", "SERGEANT", "LIUTENANT", "CAPTAIN", "MAJOR", "COLONEL", "GENERAL", "MARSHAL", "BOMB"}
        and not {pieceConf1.quantity, pieceConf2.quantity} subset {1,8,5,4,3,2,6};


public initGame: () ==> ()
initGame() == (
    initPieceConfigurations();
    givePiecesP1();
    givePiecesP2();
)
pre defaultPieces = []
    and playerOne.getPieces() = [] 
    and playerTwo.getPieces() = []
post defaultPieces <> []
    and len playerOne.getPieces() = 40
    and len playerTwo.getPieces() = 40;
  

public givePiecesP1: () ==> ()
givePiecesP1() == (
    givePieces(<Blue>, playerOne);
)
pre playerOne.getPieces() = []
post len playerOne.getPieces() = 40
    and not exists piece in set elems playerOne.getPieces() & piece.getColor() <> <Blue>;


public givePiecesP2: () ==> ()
givePiecesP2() == (
    givePieces(<Red>, playerTwo);
)
pre playerTwo.getPieces() = []
post len playerTwo.getPieces() = 40
    and not exists piece in set elems playerTwo.getPieces() & piece.getColor() <> <Red>;


private givePieces: Piece`ColorPiece * Player ==> ()
givePieces(color, player) == (
    for all pieceConf in set elems defaultPieces do (
        for all i in set {1,...,pieceConf.quantity} do (
            player.addPiece(new Piece(pieceConf.rank, color, pieceConf.name));
        );
    );
)
pre color in set {<Blue>, <Red>}
    and player = playerOne or player = playerTwo
post not exists pieceConf in set elems defaultPieces & pieceConf.quantity <> countPiecesWithRank(player.getPieces(), pieceConf.rank);


private countPiecesWithRank: seq of Piece * nat ==> nat
countPiecesWithRank(pieces, rank) == (
    dcl counter: nat;
    counter := 0;

    for all piece in set elems pieces do (
        if piece.getRank() = rank
        then counter := counter + 1;
    );
    return counter;
)
pre rank in set {0,...,12}
    and len pieces <> 0
post RESULT in set {1,8,5,4,3,2,6};
    

public placeInitialPieces: () ==> ()
placeInitialPieces() == (
    board.placePiecesP1(playerOne.getPieces());
    playerOne.removePieces();

    board.placePiecesP2(playerTwo.getPieces()); 
    playerTwo.removePieces();
)
pre board.getNumberPiecesOnBoard() = 0
    and playerOne.getPieces() <> []
    and playerTwo.getPieces() <> []
post board.getNumberPiecesOnBoard() = 80
    and playerOne.getPieces() = []
    and playerTwo.getPieces() = [];

    
public getPlayerOne: () ==> Player
getPlayerOne() == (
    return playerOne;    
)
post RESULT = playerOne;
    

public getPlayerTwo: () ==> Player
getPlayerTwo() == (
    return playerTwo;    
)
post RESULT = playerTwo;
 

public getCurrentPlayer: () ==> Player
getCurrentPlayer() == (
    return currentPlayer;    
)
post RESULT = currentPlayer 
    and (currentPlayer = playerOne or currentPlayer = playerTwo);


public getBoard: () ==> Board
getBoard() == (
    return board;
)
post RESULT = board;


public makeMove: Coord * Coord ==> nat
makeMove(srcPos, destPos) == (
    dcl srcPiece: Piece;
    dcl destPiece: Piece;
    dcl result: nat;
    
    if board.isPositionFree(srcPos) or board.isPositionLake(srcPos)
    then return 1;
    
    srcPiece := board.getPieceAtPosition(srcPos);
    
    if srcPiece.getColor() <> currentPlayer.getColor()
    then return 2
    elseif board.isPositionLake(destPos)
    then return 3;
    
    if board.isPositionFree(destPos)
    then (
        result := moveIsValid(srcPos, destPos, srcPiece);

        if result = 0
        then (
            -- make the move
            board.movePiece(srcPos, destPos);
            return 0;
        )
        else return result;
    );

    destPiece := board.getPieceAtPosition(destPos);
    
    -- nao pode ir para uma posicao ocupada por uma peca dele
    if destPiece.getColor() = currentPlayer.getColor()
    then return 6;

    -- moveu para cima de uma peca inimiga, inicia combate  
    makeBattle(srcPos, destPos, srcPiece, destPiece);
    return 0;
);
--post RESULT in set {0,...,6}
--PORQUE que retorna 0,1,2,3,6???

private makeBattle: Coord * Coord * Piece * Piece ==> ()
makeBattle(srcPos, destPos, srcPiece, destPiece) == (
    -- MINER nao morre com as bombas
    -- SPY consegue matar o MARSHAL
    -- BOMB destroi qualquer peca menos o MINER
    -- FLAG morre com todos e acaba o jogo
    
    if srcPiece.getName() = "MINER" and destPiece.getName() = "BOMB"
        or
        srcPiece.getName() = "SPY" and destPiece.getName() = "MARSHAL"
    then (
        makeBattleAux(srcPos, destPos, destPiece);
    )
    else (
        if srcPiece.getRank() = destPiece.getRank()
        then (
            board.removePiece(srcPos);
            board.removePiece(destPos);
            currentPlayer.addDeadPiece(srcPiece);
            addDeadPieceToEnemy(destPiece);
        )
        elseif srcPiece.getRank() > destPiece.getRank()
        then (
            makeBattleAux(srcPos, destPos, destPiece);
        )
        else (
            board.removePiece(srcPos);
            currentPlayer.addDeadPiece(srcPiece);
        );
    
        --if destPiece.getName() = "FLAG"
        --then gameOver(); --TODO gameOver function
    )
);


private makeBattleAux: Coord * Coord * Piece ==> ()
makeBattleAux(srcPos, destPos, destPiece) == (
    board.removePiece(destPos);
    board.movePiece(srcPos, destPos);
    addDeadPieceToEnemy(destPiece);
);


private addDeadPieceToEnemy: Piece ==> ()
addDeadPieceToEnemy(piece) == (
    if currentPlayer = playerOne
    then playerTwo.addDeadPiece(piece)
    else playerOne.addDeadPiece(piece);                               
);


public moveIsValid: Coord * Coord * Piece ==> nat
moveIsValid(srcPos, destPos, srcPiece) == (

    -- movimentos na diagonal nao sao validos
    if (srcPos.getX() <> destPos.getX() and srcPos.getY() <> destPos.getY())
    then return 11;
    
    -- pecas imoveis nao se podem mover
    if srcPiece.getName() in set {"FLAG", "BOMB"}
    then return 12
    elseif srcPiece.getName() = "SCOUT"
    then (
        -- check middle positions
        if middlePositionsAreFree(srcPos, destPos)
        then return 0
        else return 14;
    )
    else (
        if abs (destPos.getX() - srcPos.getX()) = 1 or abs (destPos.getY() - srcPos.getY()) = 1
        then return 0
        else return 13;
    );
);
--post RESULT in set {11,...,14}
    

public middlePositionsAreFree: Coord * Coord ==> bool
middlePositionsAreFree(srcPos, destPos) == (
    dcl positions: seq of Coord;

    if srcPos.getY() > destPos.getY() --norte
    then (
        positions := [new Coord(srcPos.getX(), y) | y in set {destPos.getY()+1,...,srcPos.getY()-1}];
    )
    elseif srcPos.getY() < destPos.getY() --sul
    then (
        positions := [new Coord(srcPos.getX(), y) | y in set {srcPos.getY()+1,...,destPos.getY()-1}];
    )
    elseif srcPos.getX() > destPos.getX() --oeste
    then (
        positions := [new Coord(x, srcPos.getY()) | x in set {destPos.getX()+1,...,srcPos.getX()-1}];
    )
    elseif srcPos.getX() < destPos.getX() --este
    then (
        positions := [new Coord(x, srcPos.getY()) | x in set {srcPos.getX()+1,...,destPos.getX()-1}];
    );

    for all position in set elems positions do (
        if not board.isPositionFree(position)
        then return false;
    );
    return true;
);


-- change operations
public updateTurn: () ==> ()
updateTurn() == (
    if currentPlayer = playerOne
    then currentPlayer := playerTwo
    else currentPlayer := playerOne;
);

public isGameOver() == is not yet specified;



functions

end Stratego
