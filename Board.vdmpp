/**
  Board.

  <p>
  description
  </p>

  @version
  @author
*/

class Board

types

values
    private BOARDSIZE = 10;
    private P1_INITIAL_Y = 7;
    private P1_FINAL_Y = 10;
    private P2_INITIAL_Y = 1;
    private P2_FINAL_Y = 4;

instance variables
    private board: seq of seq of [Piece];
    private lakes: seq of Coord;
    --inv len lakes = 8;
operations

-- constructor for Board
public Board: () ==> Board
Board() == (
  initBoard();
  initLakes();
);


-- consult operations
public getPieceAtPosition: Coord ==> [Piece]
getPieceAtPosition(pos) == (
    return board(pos.getY())(pos.getX());
)
pre pos.getX() in set {1,...,BOARDSIZE} and pos.getY() in set {1,...,BOARDSIZE}
post RESULT = board(pos.getY())(pos.getX());                         

public isPositionFree: Coord ==> bool
isPositionFree(pos) == (
    return board(pos.getY())(pos.getX()) = nil 
    and 
    not isPositionLake(pos);
)
pre pos.getX() in set {1,...,BOARDSIZE} and pos.getY() in set {1,...,BOARDSIZE}
post RESULT = (board(pos.getY())(pos.getX()) = nil) or RESULT = not isPositionLake(pos);

public isPositionLake: Coord ==> bool
isPositionLake(pos) == (
    return exists coord in set elems lakes & Coord`areEqual(pos, coord);
)
pre pos.getX() in set {1,...,BOARDSIZE} and pos.getY() in set {1,...,BOARDSIZE}
post RESULT = exists coord in set elems lakes & coord.getX() = pos.getX()
    and coord.getY() = pos.getY();      

public placePiecesP1: seq of Piece ==> ()
placePiecesP1(pieces) == (
    placePieces(pieces, P1_INITIAL_Y, P1_FINAL_Y);
)
--as pecas tem de ter a mesma cor
--se ja existem pecas colocadas na board, nao pode ser da mesma cor
pre len pieces = 40
    and not exists piece1, piece2 in set elems pieces & piece1 <> piece2 and piece1.getColor() <> piece2.getColor()
    and not exists piece in set elems pieces & board(P2_INITIAL_Y)(1) <> nil and piece.getColor() = board(P2_INITIAL_Y)(1).getColor(); --nao podem ser da cor do outro jogador
-- TODO falta verificar que as pecas ficaram todas no sitio certo

public placePiecesP2: seq of Piece ==> ()
placePiecesP2(pieces) == (
    placePieces(pieces, P2_INITIAL_Y, P2_FINAL_Y);
)
pre len pieces = 40 
    and not exists piece1, piece2 in set elems pieces & piece1 <> piece2 and piece1.getColor() <> piece2.getColor()
    and not exists piece in set elems pieces & board(P2_INITIAL_Y)(1) <> nil and piece.getColor() = board(P1_INITIAL_Y)(1).getColor(); --nao podem ser da cor do outro jogador
-- TODO faltar verificar que as pecas ficaram todas no sitio certo

private placePieces: seq of Piece * nat1 * nat1 ==> ()
placePieces(pieces, initialY, finalY) == (
    dcl counter: nat1;
    counter := 1;
    
    for all i in set {initialY,...,finalY} do (
        for all j in set {1,...,10} do (
            board(i)(j) := pieces(counter);
            counter := counter +1;
        );
    );
)
pre len pieces = 40 and initialY in set {1,7} and finalY in set {4,10}
    and not exists piece1, piece2 in set elems pieces & piece1 <> piece2 and piece1.getColor() <> piece2.getColor();

public getNumberPiecesOnBoard: () ==> nat
getNumberPiecesOnBoard() == (
    dcl counter: nat;
    counter := 0;
    for all row in set elems board do (
        for all pos in set elems row do (
            if pos <> nil
            then counter := counter + 1;
        );
    );
    return counter;
)
post RESULT >= 0 and RESULT <= 80;
-- TODO aqui devia ver se o RESULT e mesmo igual a uma contagem das pecas?

public movePiece: Coord * Coord ==> seq of seq of [Piece]
movePiece(pos1, pos2) == (
    dcl piece: Piece;
    piece := removePiece(pos1);
    board(pos2.getY())(pos2.getX()) := piece;
    return board;
) 
pre not Coord`areEqual(pos1, pos2)
    and pos1.getX() in set {1,...,BOARDSIZE}
    and pos1.getY() in set {1,...,BOARDSIZE}
    and pos2.getX() in set {1,...,BOARDSIZE}
    and pos2.getY() in set {1,...,BOARDSIZE}
    and getPieceAtPosition(pos1) <> nil --tem que ter peca na posicao inicial
    and isPositionFree(pos2)
post getPieceAtPosition(pos1) = nil
    and getPieceAtPosition(pos2) <> nil
    and RESULT = board;

public removePiece: Coord ==> Piece
removePiece(pos) == (
    dcl piece: Piece;
    piece := board(pos.getY())(pos.getX());
    board(pos.getY())(pos.getX()) := nil;
    return piece;
)
pre getPieceAtPosition(pos) <> nil
    and pos.getX() in set {1,...,BOARDSIZE}
    and pos.getY() in set {1,...,BOARDSIZE}; 
--pos nao pode ser uma casa vazia

public getBoard: () ==> seq of seq of [Piece]
getBoard() == (
    return board;
);
-- pre ?
-- post res tem que ser = board



-- change operations

public initBoard: () ==> ()
initBoard() == (
    dcl row: seq of [Piece];
    board := [];
    
    for all i in set {1,...,10} do (
        row := [];
        for all j in set {1,...,10} do (
            row := row ^ [nil];                              
        );
        board := board ^ [row];
    );
);

public initLakes: () ==> ()
initLakes() == (
    lakes := [ 
        new Coord(2,4),
        new Coord(2,5),
        new Coord(3,4),
        new Coord(3,5),
        new Coord(6,4),
        new Coord(6,5),
        new Coord(7,4),
        new Coord(7,5)
    ];             
);
 

public addPiece(p : Piece, x: nat, y: nat) == is not yet specified;
public isFree(c : Coord) res : bool == is not yet specified;


functions

end Board
